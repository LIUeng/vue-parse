# Vue2 ä¸­çš„å“åº”å¼åŸç†

## æµç¨‹å›¾

![Vue2.xå“åº”å¼æ¸²æŸ“](./v2.å“åº”å¼æ¸²æŸ“.svg)

## æ€è€ƒ

> ä»¥ Vue computed é€‰é¡¹å¼è§£æ

```js
// Test
const app = new Vue({
  data() {
    return {
      msg: '',
    };
  },
  computed: {
    c_msg({ msg }) {
      return msg + ' world';
    },
  },
  render() {
    this.msg = 'hello';
    return this.c_msg;
  },
});
app.$mount('#root');
```

å½“`data`å˜åŒ–æ—¶ï¼Œ`computed`å¦‚ä½•ç›‘å¬åˆ°å˜åŒ–ï¼Œæ›´æ–°æ¸²æŸ“

## ğŸ•¹ å°æç¤º

`å“åº”å¼æ•°æ® Vue2 ä½¿ç”¨ Object.defineProperty`

å½“ä¸€ä¸ªå¯¹è±¡è¢«ä»£ç†æ—¶ï¼Œè§£æ„ä¹Ÿèƒ½ç›‘å¬å˜åŒ–ï¼Œå¦‚ä¸‹

```js
let target = { a: 1, b: 2 };
// defineProperty
let keys = Object.keys(target);
for (let i = 0; i < keys.length; i++) {
  let key = keys[i];
  let value = target[key];
  Object.defineProperty(target, key, {
    configurable: true,
    enumerable: true,
    get() {
      console.log('get');
      return value;
    },
    set(newValue) {
      value = newValue;
      target[key] = newValue;
    },
  });
}
// è§£æ„æ—¶ targe.a
let { a } = target;
// è¾“å‡º get
// proxy
const targetProxy = new Proxy(target, {
  set(o, key, value, receiver) {
    Reflect.set(o, key, value, receiver);
    return true;
  },
  get(o, key, receiver) {
    console.log('proxy get');
    return Reflect.get(o, key, receiver);
  },
});
// è§£æ„æ—¶ targetProxy.b
let { b } = targetProxy;
// è¾“å‡º proxy get
```

## å‘å¸ƒè®¢é˜…è€…æ¨¡å¼

`Vue2.x` ä¸­å…³æ³¨ `Dep.target` å±æ€§ï¼ˆå½“å‰è¿è¡Œçš„ç»„ä»¶å®ä¾‹ï¼‰

> æ ¸å¿ƒç»„ä»¶

- å‘å¸ƒè€…(Publisher)ï¼šè´Ÿè´£ç»´æŠ¤è®¢é˜…è€…åˆ—è¡¨ï¼Œæä¾›æ·»åŠ ã€åˆ é™¤è®¢é˜…è€…çš„æ–¹æ³•ï¼Œå¹¶åœ¨çŠ¶æ€æ”¹å˜æ—¶é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
- è®¢é˜…è€…(Subscriber)ï¼šå®šä¹‰æ›´æ–°æ¥å£ï¼Œå½“æ”¶åˆ°å‘å¸ƒè€…é€šçŸ¥æ—¶æ‰§è¡Œç›¸åº”çš„æ›´æ–°æ“ä½œ
- äº‹ä»¶ä¸­å¿ƒ(Event Center)ï¼šå¯é€‰çš„ä¸­ä»‹è€…ï¼Œç®¡ç†å‘å¸ƒè€…å’Œè®¢é˜…è€…ä¹‹é—´çš„å…³ç³»

![Vue2.x å‘å¸ƒè®¢é˜…è€…æ¨¡å¼](./v2.å‘å¸ƒè®¢é˜…è€…æ¨¡å¼.svg)

- Observer
  - å®šä¹‰æ•°æ®ï¼Œç›‘å¬è§¦å‘å˜åŒ–ï¼Œé€šçŸ¥å‘å¸ƒè€…
- Watcher
  - æ·»åŠ è®¢é˜…è€…
- Dep å‘å¸ƒè€…
  - è§¦å‘è®¢é˜…è€…

> ä»£ç å®ç°å¦‚ä¸‹

### Watcher

```js
class Watcher {
  constructor(vm, fn, cb, options) {
    this.vm = vm;

    // lazy å±æ€§ç”¨äº computed ä½¿ç”¨
    if (options) {
      this.lazy = !!options.lazy;
    } else {
      this.lazy = false;
    }
    this.dirty = this.lazy;

    // è®°å½•å‘å¸ƒè€…
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();

    // åˆå§‹æ‰§è¡Œå‡½æ•°
    this.fn = fn;
    this.value = this.lazy ? void 0 : this.get();
  }
  get() {
    pushTarget(this);
    let vm = this.vm;
    let value = this.fn.call(vm, vm);
    popTarget();
    this.cleanupDeps();
    return value;
  }
  addDep(dep) {
    let id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        // æ·»åŠ è®¢é˜…è€…
        dep.addSub(this);
      }
    }
  }
  cleanupDeps() {
    let i = this.deps.length;
    while (i--) {
      let dep = this.deps[i];
      console.log('remove sub', dep.id, !this.newDepIds.has(dep.id));
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    let tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  }
  update() {
    if (this.lazy) {
      this.dirty = true;
    } else {
      this.run();
    }
  }
  run() {
    this.value = this.get();
  }
  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }
  depend() {
    let i = this.deps.length;
    console.log('this.deps', this.deps);
    while (i--) {
      this.deps[i].depend();
    }
  }
  // teardown
}
```

### Dep

```js
let uid = 0;
class Dep {
  constructor() {
    this.id = uid++;
    this.subs = [];
  }
  addSub(sub) {
    this.subs.push(sub);
  }
  removeSub(sub) {
    this.subs.splice(this.subs.indexOf(sub), 1);
  }
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }
  notify() {
    console.log('subs', this.subs);
    for (let i = 0; i < this.subs.length; i++) {
      this.subs[i].update();
    }
  }
}
Dep.target = null;
let stack = [];
function pushTarget(target) {
  stack.push(target);
  Dep.target = target;
}
function popTarget() {
  stack.pop();
  Dep.target = stack[stack.length - 1];
}
```

### å®šä¹‰å“åº”å¼æ•°æ®

`å“åº”å¼æ•°æ®å®šä¹‰ï¼Œå¹¶ä¸”å¦‚ä½•å‘å¸ƒæ¶ˆæ¯ï¼Œè®¢é˜…è€…æ¥æ”¶ï¼Œç„¶åæ‰§è¡Œ`

```js
const NOOP = function () {};
const computedWatcherOptions = { lazy: true };
class Vue {
  constructor(options) {
    this.$options = options;
    this.init();
  }
  init() {
    let vm = this;
    let options = this.$options;

    // data
    if (options.data) {
      let data = (vm._data = options.data.call(vm, vm));
      let keys = Object.keys(data);
      let i = keys.length;
      // å€ŸåŠ©å®ä¾‹ vm._data å±æ€§æ¥ç›‘å¬å®ä¾‹ data å±æ€§å˜åŒ–
      while (i--) {
        let key = keys[i];
        Object.defineProperty(vm, key, {
          configurable: true,
          enumerable: true,
          get() {
            return vm._data[key];
          },
          set(value) {
            vm._data[key] = value;
          },
        });
      }
      observe(data);
    }

    // computed
    if (options.computed) {
      let computed = options.computed;
      const watchers = (vm._computeWatchers = Object.create(null));
      for (let key in computed) {
        let getter = computed[key];
        watchers[key] = new Watcher(vm, getter, NOOP, computedWatcherOptions);
        Object.defineProperty(vm, key, {
          configurable: true,
          enumerable: true,
          get() {
            let watcher = vm._computeWatchers[key];
            console.log(watcher);
            if (watcher) {
              if (watcher.dirty) {
                watcher.evaluate();
              }
              if (Dep.target) {
                watcher.depend();
              }
            }
            return watcher.value;
          },
          set: NOOP,
        });
      }
    }
  }
  $mount() {
    let vm = this;
    let options = this.$options;
    // åˆå§‹æ¸²æŸ“å‡½æ•°
    new Watcher(vm, options.render, NOOP);
  }
}
function observe(value) {
  let ob = new Observer(value);
  return ob;
}
class Observer {
  constructor(value) {
    this.value = value;
    // æ™®é€šå¯¹è±¡
    this.walk(value);
  }
  walk(obj) {
    let keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  }
}
function defineReactive$$1(obj, key) {
  let dep = new Dep();
  let val = obj[key];
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get() {
      // è·å–å€¼ï¼Œå‘å¸ƒæ¶ˆæ¯
      console.log('Dep.target', Dep.target);
      if (Dep.target) {
        dep.depend();
      }
      return val;
    },
    set(newValue) {
      if (val === newValue) return;
      val = newValue;
      // å€¼å˜åŒ–äº†ï¼Œé€šçŸ¥æ›´æ–°
      dep.notify();
    },
  });
}
```

## å‚è€ƒé“¾æ¥

[å®Œæ•´ä»£ç å‚è€ƒ](https://github.com/LIUeng/vue-parse/blob/master/src/articles/computed.v2.js)

## END
